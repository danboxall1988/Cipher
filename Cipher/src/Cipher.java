import java.util.*;
/**
 *
 * @author Dan Boxall
 */
public class Cipher 
{
    private SortedMap<Character, List<Character>> tabulaRecta;
    
    public Cipher()
    {
        super();
        this.tabulaRecta = new TreeMap<>();
        this.populateTabula();
    }
    
    /**
     * Populates the tabula recta, which is a square table of alphabets,
     * each row of which is made by shifting the previous one to the left
     */
    private void populateTabula()
    {
        List<Character> line;
        char[] alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();
        for (int startIndex = 0; startIndex < 26; startIndex++)
        {
            line = new ArrayList<>();
            int index = startIndex;
            while (line.size() < 26)
            {
                if (index == 26)
                {
                    index = 0;
                }
                line.add(alphabet[index]);
                index++;
            }
            this.tabulaRecta.put(alphabet[startIndex], line);
        }
    }
    
    /**
     * Prints out the entire tabula recta
     */
    public void printTabula()
    {
        for (char c : this.tabulaRecta.keySet())
        {
            System.out.println(c + ":" + this.tabulaRecta.get(c));
        }
    }
    
    /**
     * Uses the same method of substitution as vigenere, except the 
     * key is auto generated by combining the message and the users
     * key
     */
    public String encodeAutokey(String message, String key)
    {
        StringBuilder autokey = new StringBuilder(key);
        autokey.append(message);
        return this.encodeVigenere(message, autokey.toString());
    }
    
    public String decodeAutokey(String message, String key)
    {
        StringBuilder autokey = new StringBuilder(key);
        int index = 0;
        List<Character> line;
        List<Character> alphabet = this.tabulaRecta.get('A');
        while (autokey.length() < message.length() + key.length())
        {
            if (Character.isAlphabetic(message.charAt(index)))
            {
                line = this.tabulaRecta.get(autokey.charAt(index));
                char letter = alphabet.get(line.indexOf(message.charAt(index)));
                autokey.append(letter);
                index++;
            }
            else
            {
                autokey.append(message.charAt(index));
            }
        }
        return autokey.substring(key.length());
        
    }
    
    public String encodeVigenere(String message, String key)
    {
        StringBuilder newStr = new StringBuilder();
        int keyIndex = 0;
        List<Character> line;
        List<Character> alphabet = this.tabulaRecta.get('A');
        for (char c : message.toCharArray())
        {
            if (Character.isAlphabetic(c))
            {
                if (keyIndex == key.length())
                {
                    keyIndex = 0;
                }
                line = this.tabulaRecta.get(key.charAt(keyIndex));
                newStr.append(line.get(alphabet.indexOf(c)));
                keyIndex++;
            }
            else
            {
                newStr.append(c);
            }
        }
        return newStr.toString();
    }
    
    public String decodeVigenere(String encodedText, String key)
    {
        StringBuilder newStr = new StringBuilder();
        int keyIndex = 0;
        List<Character> line;
        List<Character> alphabet = this.tabulaRecta.get('A');
        for (char c : encodedText.toCharArray())
        {
            if (Character.isAlphabetic(c))
            {
                if (keyIndex == key.length())
                {
                    keyIndex = 0;
                }
                line = this.tabulaRecta.get(key.charAt(keyIndex));
                newStr.append(alphabet.get(line.indexOf(c)));
                keyIndex++;
            }
            else
            {
                newStr.append(c);
            }
        }
        return newStr.toString();
    }
    
    public String encodeCaeser(String message, int offset)
    {
        StringBuilder newStr = new StringBuilder();
        char letter;
        for (char c : message.toCharArray())
        {
            if (Character.isAlphabetic(c))
            {
                letter = (char) (c + offset);
                if (letter > 'Z')
                {
                    letter = (char) (letter - 26);
                }
                newStr.append(letter);
            }
            else
            {
                newStr.append(c);
            }
        }
        return newStr.toString();
    }
    
    public String decodeCaeser(String text, int offset)
    {
        StringBuilder newStr = new StringBuilder();
        char letter;
        for (char c : text.toCharArray())
        {
            if (Character.isAlphabetic(c))
            {
                letter = (char) (c - offset);
                if (letter < 'A')
                {
                    letter = (char) (letter + 26);
                }
                newStr.append(letter);
            }
            else
            {
                newStr.append(c);
            }
        }
        return newStr.toString();
    }
    
    public String bruteForceCaeser(String message)
    {
        StringBuilder versions = new StringBuilder();
        for (int i = 1; i < 26; i++)
        {
            versions.append(this.encodeCaeser(message, i));
            versions.append("\n");
        }
        return versions.toString();
    }
}
